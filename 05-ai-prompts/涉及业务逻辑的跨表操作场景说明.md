# 涉及业务逻辑的跨表操作场景说明

## 概述

本文档说明"涉及业务逻辑的跨表操作"的具体场景，以及何时应该使用 Service 层而非 Repository 层。

## 具体场景

### 场景 1：发送邮件（写多表 + 业务规则）

这个操作涉及：`EmailSend`、`EmailBatch`、`SuppressionList` 三个表，还有业务规则：检查抑制列表、更新批次计数。

```python
async def send_email(self, request):
    # 1. 检查收件人是否在抑制列表（查 SuppressionList）
    if await self.suppression_repo.is_suppressed(request.to):
        raise EmailSuppressedException()

    # 2. 创建邮件记录（写 EmailSend）
    email = await self.email_repo.create(...)

    # 3. 更新批次计数（写 EmailBatch）
    await self.batch_repo.increment_counts(batch_id, sent_delta=1)

    # 4. 调用 SES 发送
    await self.ses_client.send(...)
```

这里有业务规则（抑制检查）+ 多表写入，放 Service 合适。

### 场景 2：处理回复邮件

涉及：`EmailReply`、`EmailSend`、S3 存储，业务逻辑：匹配原始邮件、解析邮件内容。

```python
async def process_reply(self, ses_message_id: str):
    # 1. 幂等检查（查 EmailReply）
    existing = await self.reply_repo.get_by_ses_message_id(ses_message_id)
    if existing:
        return existing

    # 2. 从 S3 获取邮件内容
    raw_email = await self.s3_client.get_object(...)

    # 3. 解析邮件，匹配原始邮件（查 EmailSend）
    original = await self.email_repo.find_by_subject_and_recipient(...)

    # 4. 保存回复记录（写 EmailReply）
    reply = await self.reply_repo.create(...)
```

### 场景 3：处理 SES 事件通知

涉及：`EmailEvent`、`EmailSend`、`SuppressionList`、`ReputationMetrics`，业务逻辑：根据事件类型执行不同操作。

```python
async def handle_bounce_event(self, event_data):
    # 1. 记录事件（写 EmailEvent）
    await self.event_repo.create_event(...)

    # 2. 更新邮件状态（写 EmailSend）
    await self.email_repo.update_status(message_id, EmailStatus.BOUNCED)

    # 3. 硬退信加入抑制列表（写 SuppressionList）
    if event_data["bounceType"] == "Permanent":
        await self.suppression_repo.add_to_suppression(...)

    # 4. 更新声誉指标（写 ReputationMetrics）
    await self.metrics_repo.upsert(...)
```

## 对比：纯数据查询（适合放 Repository）

这种只是简单的关联查询，没有业务规则，可以放在 `EmailSendRepository`。

```python
async def get_email_with_events(self, message_id: str):
    """获取邮件及其事件历史 - 纯数据组装"""
    query = (
        select(EmailSend, EmailEvent)
        .outerjoin(EmailEvent, EmailSend.message_id == EmailEvent.message_id)
        .where(EmailSend.message_id == message_id)
    )
    # 只是 JOIN 查询，没有业务判断
```

## 判断标准

| 特征 | 放 Repository | 放 Service |
|------|---------------|------------|
| 只读查询 | ✅ | |
| 单表写入 | ✅ | |
| 多表写入 | | ✅ |
| 有条件分支逻辑 | | ✅ |
| 调用外部服务（SES/S3） | | ✅ |
| 事务边界控制 | | ✅ |

## 核心区别

**Repository** 是"数据怎么存取"，**Service** 是"业务怎么运转"。
